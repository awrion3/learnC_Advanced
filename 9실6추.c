#pragma warning(disable:4996)
#include <stdio.h>

//함수 선언
int input(int*);
int* sel_next(int*);
int number(int*, int*);

int main(void) {

	int x[100], N, *r = x, *s, R; //배열, 배열 크기, 두 포인터, 하나의 정수 반환값

	N = input(x); //함수 호출 및 배열 -1 포함했으나, 길이 계산에서는 제외하고 반환

	for (; *(r + 1) != -1;) { 
	//범위 설정1: r < x + N으로 설정해놓으면,
	//이후 함수 호출부의 r + 1에서 넘어버리는 경우가 존재하므로 호출 전에 확실히 설정
		s = sel_next(r); //함수 호출 및 조건 만족하는 구간 내 마지막 원소 주소 반환

		R = number(r, s); //함수 호출 및 해당 구간 내 하나의 정수 만들어 반환

		printf("%d\n", R); //하나의 정수 반환값 출력

		r = s; //이 경우에는 현재 위치부터 그대로 다시 시작함//
	}

	return 0;
}

//함수 정의
int input(int *p) {

	int *pa = p, cnt = 0;

	for (; pa < p + 100; pa++) {
		scanf("%d", pa);

		if (*pa == -1) //-1 입력에는 포함하되
			break;
		else           //배열 길이에는 cnt되지 않게 함
			cnt++;
	}

	return cnt;
}

int* sel_next(int *p) { //이전의 원소 주소 시작점 인자로 받음

	int *pa = p + 1, *q; //아래 비교를 고려해 인덱스 -1 조정 
	int up = 0;

	//동일한 숫자가 연속해서 입력되는 경우는 없으므로 두 경우로만 나뉨
	if (*(pa - 1) < *pa) //앞보다 증가한 경우
		up = 1;
	else if (*(pa - 1) > *pa) //앞보다 감소한 경우
		up = 0;

	q = pa++; //생각: 이 함수에 한번 들어온 이상, 인접한 원소는 증가, 혹은 감소 패턴이 반드시 존재한다
	//따라서 q 반환값은 언제나 pa값 즉, 본래 위치p의 +1된 값으로 반환되어야 한다
	//또한 아래 반복문 진입하지 않더라도 이렇게 조정된 값으로 반환되는 기능을 하기도 함
	//또 ++가 의미를 지니는 것은 아래 반복문 진입하였을 때에만. 즉, 위의 up은 초기화 역할을 하게 됨.

	for (; *pa != -1; pa++) { //범위 설정2: 계속 변동하는 포인터만 인자로 받았으므로, 이렇게 범위를 확실히 설정함(-1은 계산에 고려 안 하므로)
		if (*(pa - 1) < *pa) { //이전값보다 증가한 경우
			if (up == 1)	//+연속해서! 증가한 경우
				q = pa; //에만 q 갱신
			else
				break; //증가했더라도, 초기화 대비 계속 연속해서 증가한 게 아니라면, 즉 2 1 3과 같은 패턴(감소-증가)이라면 해당아님
		}
		else if (*(pa - 1) > *pa) { //이전값보다 감소한 경우
			if (up == 0)	//+연속해서! 감소한 경우
				q = pa;	//에만 q 갱신
			else
				break; //감소했더라도, 초기화 대비 계속 연속해서 감소한 게 아니라면, 즉 3 4 2과 같은 패턴(증가-감소)이라면 해당아님
		}
	}

	return q;
}

int number(int *p, int *q) { //x[m] 인덱스 및 위 함수에서 반환된 주소 위치 인자 (즉 둘다 포함해야)

	int *r = p, sum = 0; //해당 구간 내

	for (; r <= q; r++) {	//값들로 하나의 정수 만들어 반환
		sum *= 10; //자연스레 0XX값은 XX값으로 출력되게 됨
		sum += *r;
	}

	return sum;
}

/*
1 2 3 4 5 4 3 2 3 4 2 -1

8 6 4 2 1 0 3 5 7 1 4 -1
*/